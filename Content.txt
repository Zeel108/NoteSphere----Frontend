how data flow or how react + spring works
		 
	--->step by step with the correct sequence :

			1. **React initial load**
			
			   * When the website opens, `App.js` is rendered.
			   * Based on the route (`/`), React Router loads the component (e.g., `NotesList.js`). 
			   								Because for url '/' the notelist.jsis connected
			   		
			   		
			   		function App() {					after app.js render it's function App() called
							  return (					Than it's return method call
							    <BrowserRouter>				here we can print or write code that we want in our web 
							    							but we don't write here in place of it we write it in 
							    								different .js file inside components folder for this 
							    								we also import function of that file like
							    								import AddNote from "./components/AddNote";
							    								than what ever user clicks on any url that .js file we goes 
							
							              <div>
							                <Navbar />
							              </div>
							        
							        <Routes>
							            <Route path="/" element={<NotesList /> } />
							            <Route path="*" element={<NotFound />} />
							            <Route path="/addnote" element={<AddNote />} />   here if user click path is set and we goto AddNote
							        </Routes>                                           
							    
							    </BrowserRouter>
							  );
							}
							
							export default App;
										   		
			   * `NotesList.js` runs, fetches notes from backend, and prints them in Chrome console/UI.
			
			2. **Navigation to Add Note**
			
			   * User clicks on navbar → route changes to `/addnote`.
			   * React Router loads `AddNote.js`.
			   * `AddNote.js` returns the form UI (from its `return()` JSX).
			
			3. **User fills form & submits**
			
			   * Input values are stored in state (`useState`).
			   * On button click → a function (e.g., `handleSubmit`) is called.
			   * Inside that function, data is converted into JSON.
			   * more thing excecute but we learn it in next topic 
			
			4. **Service layer in React**
			
			   * Usually, there’s a `NotesService.js` file where methods like `createNote()` are written.
			   * That function uses `axios.post("http://localhost:8080/api/notes", jsonData)` to send request.
			   * also it pick which method is called post or get so we choose method for the method createnote.
			
			5. **Spring Boot (Backend)**
			
			   * URL `/api/notes` hits the controller method with `@PostMapping("/notes")`.
			   * `@RequestBody` maps the JSON → into a `NotesEntity` object.
			   * `notesRepository.save(notesEntity)` saves the data into the database.
			   * Spring returns a JSON response of the saved note with status `201 Created`.
			
			6. **React receives response**
			
			   * Back in `AddNote.js`, `.then(response => {...})` executes on success.
			   * If success → UI can navigate back to `/` and show updated list.
			   * If failure → `.catch(error => {...})` runs and error is shown/logged.
			
			---
			
			👉 just Remember these details:
			
			* React Router decides which component (`NotesList.js`, `AddNote.js`) is shown.
			* Service functions (`NotesService.js`) handle the actual `fetch/axios` calls.
			* Backend method chosen depends on **URL mapping (`/notes`) + HTTP method (POST)**.
			
	

 ____________________________________________________________________________________________________________________________________
|																																	 |
|										why we use useEffect ( method in place of our own)											 |
|____________________________________________________________________________________________________________________________________|

--->in general we don’t use useEffect just because React gave it, but because React’s rendering model is pure and declarative.

--->If you write your own method and call it directly, it will run on every render during function execution, which is not always what you want (and can cause infinite loops if it updates state).
		useEffect tells React:

				“Run this side effect after React has updated the DOM.”

				It gives you control of when to run it (once, on dependency change, etc.) through the dependency array.
				It avoids polluting your render logic with side effects, keeping rendering predictable and side effects isolated.
				So compared to your own method:
				A normal method runs immediately when the component function runs.
				useEffect runs after render and only under the conditions you specify.
				That’s why things like data fetching, subscriptions, event listeners, DOM manipulation are done in useEffect instead of inline methods.

--->if you just call your own method inside the component body (not in useEffect), it will execute every time the component renders, which includes:

		>First load
		>Any state change
		>Any parent re-render
		>Any manual refresh

		So if your method fetches/prints a note, it will keep running again and again.

		With useEffect(() => { ... }, []), it runs only once when the component mounts, no matter how many times React re-renders internally. 
		That’s why useEffect is used to avoid repeated/unnecessary API calls or console prints.


--->In React, useEffect(() => {}); is used to run side effects in a component. The behavior depends on the second argument (the dependency array):

	* ____No dependency array____

	code:-
	useEffect(() => {
	console.log("Runs after every render");
	});

	→ Runs after every render (initial + re-renders).


	* _____Empty dependency array []______

	code:-
	useEffect(() => {
	console.log("Runs only once after first render");
	}, []);

	→ Runs only once (like componentDidMount). Common for fetching data on load.


	* _____With dependencies [x, y]______

	code:-
	useEffect(() => {
	console.log("Runs when x or y changes");
	}, [x, y]);

	→ Runs on first render + whenever x or y changes.

	It means no dependency array → effect runs every time your component re-renders.